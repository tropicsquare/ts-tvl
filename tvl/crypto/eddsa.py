from hashlib import sha512
from typing import Callable, Tuple

from Crypto.PublicKey.ECC import EccPoint
from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey

from .tmac import tmac


class ED25519_PARAMETERS:
    G = [
        0x216936D3CD6E53FEC0A4E231FDD6DC5C692CC7609525A7B2C9562D608F25D51A,
        0x6666666666666666666666666666666666666666666666666666666666666658,
    ]
    """Base point generating the underlying subgroup (X,Y coordinate)"""
    q = 0x1000000000000000000000000000000014DEF9DEA2F79CD65812631A5CF5D3ED
    """Order of the subgroup generated by G"""
    h = 0x08
    """Cofactor of the subgroup generated by G"""


EDDSA_B = EccPoint(*ED25519_PARAMETERS.G, curve="ed25519")


EdDSAComputeRFn = Callable[[bytes, bytes, bytes, bytes, bytes, bytes], bytes]


def eddsa_key_setup(k: bytes) -> Tuple[bytes, bytes, bytes]:
    """Setup a new EdDSA key.

    Args:
        k (bytes): private key

    Returns:
        scalar, prefix, public key
    """
    k_hash = sha512(k).digest()
    s_int = int.from_bytes(k_hash[:32], byteorder="little")
    s_int &= (1 << 254) - 8
    s_int |= 1 << 254
    s = s_int.to_bytes(32, byteorder="little")
    prefix = k_hash[32:]
    a = Ed25519PrivateKey.from_private_bytes(k).public_key().public_bytes_raw()
    return s, prefix, a


def ts_compute_r(
    s: bytes, prefix: bytes, a: bytes, m: bytes, h: bytes, n: bytes
) -> bytes:
    """TropicSquare's R computation function"""
    return tmac(prefix, h + n + m, b"\x0C")


def eddsa_sign(
    s: bytes,
    prefix: bytes,
    a: bytes,
    m: bytes,
    h: bytes = b"",
    n: bytes = b"",
    compute_r_fn: EdDSAComputeRFn = ts_compute_r,
) -> Tuple[bytes, bytes]:
    """Sign a message with the EdDSA algorithm.

    Args:
        s (bytes): scalar
        prefix (bytes): prefix
        a (bytes): public key
        m (bytes): message
        h (bytes): handshake hash
        n (bytes): nonce

    Returns:
        the signature (r, s)
    """
    r = compute_r_fn(s, prefix, a, m, h, n)
    r_int = int.from_bytes(r, byteorder="little") % ED25519_PARAMETERS.q

    b_ = EDDSA_B * r_int
    r_ = b_.y | ((b_.x & 1) << 255)
    r_ = r_.to_bytes(32, byteorder="little")

    e = sha512(r_ + a + m).digest()
    e_int = int.from_bytes(e, byteorder="little") % ED25519_PARAMETERS.q

    s_int = int.from_bytes(s, byteorder="little")
    s_int_ = (r_int + e_int * s_int) % ED25519_PARAMETERS.q

    s_ = s_int_.to_bytes(32, byteorder="little")
    return r_, s_
