from hashlib import sha512
from typing import Literal, Protocol, Tuple

from Crypto.PublicKey.ECC import EccPoint
from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey

from .tmac import tmac


class ED25519_PARAMETERS:
    G = [
        0x216936D3CD6E53FEC0A4E231FDD6DC5C692CC7609525A7B2C9562D608F25D51A,
        0x6666666666666666666666666666666666666666666666666666666666666658,
    ]
    """Base point generating the underlying subgroup (X,Y coordinate)"""
    q = 0x1000000000000000000000000000000014DEF9DEA2F79CD65812631A5CF5D3ED
    """Order of the subgroup generated by G"""
    h = 0x08
    """Cofactor of the subgroup generated by G"""


EDDSA_B = EccPoint(*ED25519_PARAMETERS.G, curve="ed25519")
EDDSA_KEY_SIZE = 32


class EdDSAComputeRFn(Protocol):
    def __call__(
        self, s: bytes, prefix: bytes, a: bytes, m: bytes, h: bytes, n: bytes
    ) -> int:
        ...


def _to_int(
    __bytes: bytes, /, *, byteorder: Literal["little", "big"] = "little"
) -> int:
    return int.from_bytes(__bytes, byteorder)


def _to_bytes(
    __int: int, /, *, size: int, byteorder: Literal["little", "big"] = "little"
) -> bytes:
    return __int.to_bytes(size, byteorder)


def eddsa_key_setup(k: bytes) -> Tuple[bytes, bytes, bytes]:
    """Setup a new EdDSA key.

    Args:
        k (bytes): private key

    Returns:
        scalar, prefix, public key
    """
    k_hash = sha512(k).digest()
    s_int = _to_int(k_hash[:32])
    s_int &= (1 << 254) - 8
    s_int |= 1 << 254
    s_int %= ED25519_PARAMETERS.q

    s = _to_bytes(s_int, size=32)
    prefix = k_hash[32:]
    a = Ed25519PrivateKey.from_private_bytes(k).public_key().public_bytes_raw()
    return s, prefix, a


def ts_compute_r(
    s: bytes, prefix: bytes, a: bytes, m: bytes, h: bytes, n: bytes
) -> int:
    """TropicSquare's R computation function"""

    def _reverse_endianess(x: bytes) -> bytes:
        return int.from_bytes(x, "big").to_bytes(len(x), "little")

    r1 = tmac(_reverse_endianess(prefix), h + n + m, b"\x0C")
    r2 = tmac(r1, b"", b"\x0C")
    return _to_int(r2 + r1, byteorder="big") % ED25519_PARAMETERS.q


def eddsa_sign(
    s: bytes,
    prefix: bytes,
    a: bytes,
    m: bytes,
    h: bytes = b"",
    n: bytes = b"",
    compute_r_fn: EdDSAComputeRFn = ts_compute_r,
) -> Tuple[bytes, bytes]:
    """Sign a message with the EdDSA algorithm.

    Args:
        s (bytes): scalar
        prefix (bytes): prefix
        a (bytes): public key
        m (bytes): message
        h (bytes): handshake hash
        n (bytes): nonce

    Returns:
        the signature (r, s)
    """
    r_int = compute_r_fn(s, prefix, a, m, h, n)

    b_ = EDDSA_B * r_int
    r_ = b_.y | ((b_.x & 1) << 255)
    r_ = _to_bytes(r_, size=32)

    e = sha512(r_ + a + m).digest()
    e_int = _to_int(e) % ED25519_PARAMETERS.q

    s_int = (r_int + e_int * _to_int(s)) % ED25519_PARAMETERS.q

    s_ = _to_bytes(s_int, size=32)
    return r_, s_
